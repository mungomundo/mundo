<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mundo — Big Map</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body { background:#0b1020; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const {useEffect,useMemo,useRef,useState} = React;

    /********************
     * World & pacing   *
     ********************/
    const WORLD_W = 1000;
    const WORLD_H = 1000;

    // Viewport (draw small window you can pan/zoom)
    const START_VIEW_W = 80;
    const START_VIEW_H = 60;
    const START_SCALE = 10; // px per tile at zoom=1

    // Slower, week-scale vibe
    const TICK_MS = 250;                 // ~4 ticks/sec
    const SIM_SAMPLE_PER_TICK = 6000;    // process a sample each tick (not all 1,000,000)

    /****************
     * RNG (Alea)   *
     ****************/
    function Alea(seedStr = "mundo") {
      let s0 = mash(" "), s1 = mash(" "), s2 = mash(" ");
      s0 -= mash(seedStr); if (s0 < 0) s0 += 1;
      s1 -= mash(seedStr); if (s1 < 0) s1 += 1;
      s2 -= mash(seedStr); if (s2 < 0) s2 += 1;
      function mash(data) {
        data = data.toString();
        let n = 0xefc8249d;
        for (let i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          let h = 0.02519603282416938 * n;
          n = h >>> 0; h -= n; h *= n; n = h >>> 0; h -= n; n += h * 0x100000000;
        }
        return (n >>> 0) * 2.3283064365386963e-10;
      }
      return function() {
        const t = 2091639 * s0 + 2.3283064365386963e-10 * 0x100000000;
        s0 = s1; s1 = s2; s2 = t - (t | 0);
        return s2;
      };
    }

    /****************
     * Tiles (<=16) *
     ****************/
    const TILE = {
      GRASS: 0, WATER: 1, WHEAT: 2, SAND: 3, WITCH: 4,
      TREES: 5, GOLD: 6, MOUNTAIN: 7, VILLAGE: 8
      // room up to 15 (index 0..15)
    };

    // index → { name, colorHex, loreOnSpawn(0/1), loreText }
    const tileDefs = Array(16).fill(null);
    function defTile(id, name, hex, loreOnSpawn, loreText) {
      tileDefs[id] = { id, name, hex, loreOnSpawn: loreOnSpawn ? 1 : 0, lore: loreText || "" };
    }
    // base set
    defTile(TILE.GRASS,    "grass",    "#2F9E44", 0, "");
    defTile(TILE.WATER,    "water",    "#1D4ED8", 0, "");
    defTile(TILE.WHEAT,    "wheat",    "#D9B63A", 0, ""); // default 0 (no auto-lore)
    defTile(TILE.SAND,     "sand",     "#D4A373", 0, "");
    defTile(TILE.WITCH,    "witch",    "#D946EF", 0, "A circle hums with old power.");
    // requested
    defTile(TILE.TREES,    "trees",    "#2A6F3E", 0, "");
    defTile(TILE.GOLD,     "gold",     "#FFD700", 1, "A shimmer of gold appears...");
    defTile(TILE.MOUNTAIN, "mountain", "#6B7280", 0, "");
    // for “found <name>” villages
    defTile(TILE.VILLAGE,  "village",  "#EAB308", 1, "A village is founded: %NAME%.");

    const nameToTile = Object.fromEntries(Object.values(tileDefs).filter(Boolean).map(d => [d.name, d.id]));

    // helpers
    function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
    function hexToRgb(hex) {
      const h = hex.replace('#','');
      return [parseInt(h.slice(0,2),16), parseInt(h.slice(2,4),16), parseInt(h.slice(4,6),16)];
    }
    function randomOne(arr, rnd) { return arr[(rnd() * arr.length) | 0]; }
    function sanitizeWord(raw) {
      const t = raw.trim().toLowerCase();
      return t.replace(/[^a-z0-9\-\s]+/g, "").trim();
    }
    function stableLocalUser() {
      try {
        const k = "mundo_uid";
        let v = localStorage.getItem(k);
        if (!v) { v = Math.random().toString(36).slice(2); localStorage.setItem(k, v); }
        return v;
      } catch { return Math.random().toString(36).slice(2); }
    }
    function randomUserName(rnd) {
      const A=["copper","amber","violet","moss","river","quartz","ember","dust","ivy","wren"];
      const B=["fox","otter","sparrow","wolf","lynx","badger","marten","eel","owl","moth"];
      return `${A[(rnd()*A.length)|0]}_${B[(rnd()*B.length)|0]}${(rnd()*99)|0}`;
    }

    /****************
     * App shell    *
     ****************/
    function App() {
      return (
        <div className="min-h-screen w-full bg-slate-950 text-slate-100">
          <Header />
          <Main />
          <Footer />
        </div>
      );
    }
    function Header() {
      return (
        <header className="sticky top-0 z-10 border-b border-slate-800 bg-slate-950/70 backdrop-blur">
          <div className="mx-auto flex max-w-7xl items-center justify-between px-4 py-3">
            <div className="flex items-center gap-3">
              <div className="h-8 w-8 rounded-2xl bg-gradient-to-br from-emerald-400 to-cyan-400" />
              <div className="text-xl font-semibold tracking-tight">Mundo — Big Map</div>
            </div>
            <div className="text-xs text-slate-400">1000×1000 • Pan (WASD) • Zoom (±)</div>
          </div>
        </header>
      );
    }
    function Footer() {
      return (
        <footer className="border-t border-slate-800/80">
          <div className="mx-auto max-w-7xl px-4 py-3 text-xs text-slate-400">
            Tip: Try the sequence: <code>eye-of-newt</code> → <code>toe-of-frog</code> → <code>wing-of-bat</code>.
          </div>
        </footer>
      );
    }

    /***********************
     * Main world component *
     ***********************/
    function Main() {
      // seed & rng
      const [seed, setSeed] = React.useState(() => Math.random().toString(36).slice(2));
      const rnd = React.useMemo(() => Alea(seed), [seed]);

      // world state
      const [world, setWorld] = React.useState(() => makeInitialWorld(rnd));
      const [messages, setMessages] = React.useState([]);
      const [input, setInput] = React.useState("");
      const [showAdmin, setShowAdmin] = React.useState(false);
      const [lore, setLore] = React.useState(() => [
        { id: 1, ts: Date.now(), text: "Mundo awakens. A hush over sunlit grass." },
      ]);

      // admin & verbs
      const [adminMessages, setAdminMessages] = React.useState([]);
      const [adminInput, setAdminInput] = React.useState("");
      const [customVerbs, setCustomVerbs] = React.useState([]); // {word, kind, payload}

      // weights
      const [weights, setWeights] = React.useState({
        rainBias: 0, floodIntensity: 0.4, spawnBoost: 0, chaos: 0.0, quicksandSensitivity: 0.35,
      });

      // optional websocket
      const [wsUrl, setWsUrl] = React.useState("");
      const wsRef = React.useRef(null);
      const localUID = React.useMemo(() => stableLocalUser(), []);

      // plurality & sequences
      const countsRef = React.useRef(new Map()); // word -> [timestamps]
      const sequenceRef = React.useRef({ stage: 0, lastTs: 0 });

      // villages: index -> name
      const petitionsRef = React.useRef(new Map()); // name -> Set(uids)

      // canvas & viewport
      const canvasRef = React.useRef(null);
      const rafRef = React.useRef(null);
      const [view, setView] = React.useState({
        x: 0, y: 0, w: START_VIEW_W, h: START_VIEW_H, zoom: 1, scale: START_SCALE
      });
      const hoverRef = React.useRef({ x: -1, y: -1, name: "" });

      // palette cache
      const palette = React.useMemo(() => {
        return tileDefs.map(d => d ? hexToRgb(d.hex) : [0,0,0]);
      }, []);

      // reseed
      React.useEffect(() => {
        setWorld(makeInitialWorld(rnd));
        countsRef.current = new Map();
        petitionsRef.current = new Map();
        pushLore(`The weave reshapes. New seed ${seed.slice(0,6)}.`);
      }, [rnd]);

      // tick loop (sampled)
      React.useEffect(() => {
        let last = performance.now(), acc = 0;
        const loop = (now) => {
          acc += now - last; last = now;
          while (acc >= TICK_MS) {
            setWorld(w => tickWorldSampled(w, rnd, weights));
            acc -= TICK_MS;
          }
          draw(canvasRef.current, world, view, palette);
          rafRef.current = requestAnimationFrame(loop);
        };
        rafRef.current = requestAnimationFrame(loop);
        return () => cancelAnimationFrame(rafRef.current);
      }, [rnd, weights, world, view, palette]);

      // plurality window cleanup (60s rolling)
      React.useEffect(() => {
        const iv = setInterval(() => {
          const now = Date.now();
          for (const [word, arr] of countsRef.current.entries()) {
            while (arr.length && now - arr[0] > 60000) arr.shift();
            if (!arr.length) countsRef.current.delete(word);
          }
        }, 2000);
        return () => clearInterval(iv);
      }, []);

      // lore heartbeat
      React.useEffect(() => {
        const iv = setInterval(() => {
          const wheat = worldCount(world, TILE.WHEAT);
          const water = worldCount(world, TILE.WATER);
          const villages = Object.keys(world.villages).length;
          const mood = world.meta.rainMeter > 0.6 ? "sodden" : world.meta.rainMeter < 0.2 ? "parched" : "temperate";
          const line = randomOne([
            `Farmers reckon ${wheat} plots show promise; the land feels ${mood}.`,
            `${villages || 'No'} villages dot the map; rivers cover ${water} tiles in mirror-light.`,
            `Archivists mark the winds: rain index ${(world.meta.rainMeter||0).toFixed(2)}.`,
          ], Math.random);
          pushLore(line);
          world.meta.memory.push({ ts: Date.now(), line });
        }, 45000);
        return () => clearInterval(iv);
      }, [world]);

      // websocket client (optional)
      React.useEffect(() => {
        if (!wsUrl) return;
        try {
          const ws = new WebSocket(wsUrl);
          wsRef.current = ws;
          ws.onopen = () => pushLore(`Connected to ${wsUrl}`);
          ws.onmessage = (e) => {
            let m; try { m = JSON.parse(e.data); } catch { return; }
            if (m.type === "chat") ingestChat(m.user || m.userId || randomUserName(Math.random), m.text, false, m.userId);
            if (m.type === "admin" && typeof m.cmd === 'string') runAdminCommand(m.cmd);
            if (m.type === "lore" && m.text) pushLore(m.text);
          };
          ws.onclose = () => pushLore(`Disconnected from ${wsUrl}`);
          ws.onerror = () => pushLore(`WS error on ${wsUrl}`);
          return () => ws.close();
        } catch { pushLore(`Failed to connect ${wsUrl}`); }
      }, [wsUrl]);

      function wsSend(obj) {
        if (wsRef.current && wsRef.current.readyState === 1) {
          try { wsRef.current.send(JSON.stringify(obj)); } catch {}
        }
      }

      function pushLore(text) {
        setLore(L => [{ id: Math.random(), ts: Date.now(), text }, ...L].slice(0, 200));
      }

      // chat intake
      function ingestChat(user, txt, echoWS = true, userId) {
        const uid = userId || localUID;
        setMessages(M => [...M.slice(-299), { id: Math.random(), user, userId: uid, text: txt, ts: Date.now() }]);
        if (echoWS) wsSend({ type: "chat", user, userId: uid, text: txt });
        applyRules(txt, uid);
      }

      // player chat
      function handleSend() {
        const txt = input.trim();
        if (!txt) return;
        if (txt === "/admin") { setShowAdmin(s => !s); setInput(""); return; }
        ingestChat(randomUserName(Math.random), txt, true, localUID);
        setInput("");
      }

      // admin chat
      function handleAdminSend() {
        const txt = adminInput.trim(); if (!txt) return;
        setAdminMessages(M => [...M.slice(-199), { id: Math.random(), user: "ADMIN", text: txt, ts: Date.now() }]);
        wsSend({ type: "admin", cmd: txt });
        runAdminCommand(txt);
        setAdminInput("");
      }

      // admin DSL
      function runAdminCommand(cmd) {
        const parts = cmd.trim().split(/\s+/);
        const head = (parts.shift() || '').toLowerCase();
        if (!head) return;

        if (head === 'set' && parts[0] === 'weight') {
          const key = parts[1]; const val = parseFloat(parts[2]);
          if (key in weights && !Number.isNaN(val)) {
            setWeights(w => ({ ...w, [key]: clamp(val, -1, 1) }));
            pushLore(`Director set weight ${key} → ${val.toFixed(2)}`);
          }
          return;
        }
        if (head === 'add' && parts[0] === 'spawn') {
          const word = (parts[1] || '').toLowerCase();
          const name = (parts[2] || 'wheat').toLowerCase();
          const tile = nameToTile[name] ?? TILE.WHEAT;
          if (word) {
            setCustomVerbs(v => [...v.filter(x => x.word !== word), { word, kind: 'spawn', payload: { tile } }]);
            pushLore(`Director added spawn verb '${word}' → ${tileDefs[tile].name}`);
          }
          return;
        }
        if (head === 'add' && parts[0] === 'chance') {
          const word = (parts[1] || '').toLowerCase();
          const meter = (parts[2] || 'rain').toLowerCase();
          const amount = parseFloat(parts[3] || '0.05');
          if (word) {
            setCustomVerbs(v => [...v.filter(x => x.word !== word), { word, kind: 'chance', payload: { meter, amount } }]);
            pushLore(`Director added chance verb '${word}' → ${meter}+${amount}`);
          }
          return;
        }
        if (head === 'remove') {
          const word = (parts[0] || '').toLowerCase();
          setCustomVerbs(v => v.filter(x => x.word !== word));
          pushLore(`Director removed verb '${word}'`);
          return;
        }
        if (head === 'lore') {
          const text = cmd.slice(cmd.indexOf(' ') + 1);
          if (text) { pushLore(text); wsSend({ type: 'lore', text }); }
          return;
        }
        if (head === 'reseed') { setSeed(Math.random().toString(36).slice(2)); return; }

        // otherwise treat as user word from ADMIN
        applyRules(cmd, "ADMIN");
      }

      function applyCustomVerbs(w2, lower) {
        for (const v of customVerbs) {
          if (lower !== v.word) continue;
          if (v.kind === 'spawn') {
            spawnTile(w2, v.payload?.tile ?? TILE.WHEAT, rnd, weights);
            const def = tileDefs[v.payload?.tile ?? TILE.WHEAT];
            if (def && def.loreOnSpawn) pushLore(def.lore.replace('%NAME%', ''));
          }
          if (v.kind === 'chance') {
            const meter = `${v.payload?.meter || 'rain'}Meter`;
            w2.meta[meter] = clamp((w2.meta[meter] || 0) + (v.payload?.amount || 0.05), 0, 1);
            if (meter === 'rainMeter' && w2.meta[meter] > 0.65) { doRain(w2, rnd, weights); w2.meta[meter] = 0; pushLore(`Skies answer '${v.word}'.`); }
          }
        }
      }

      // rules
      function applyRules(txt, uid) {
        // plurality tracking
        const key = sanitizeWord(txt);
        if (key) {
          if (!countsRef.current.has(key)) countsRef.current.set(key, []);
          countsRef.current.get(key).push(Date.now());
        }

        const lower = txt.toLowerCase();
        let w2 = world;

        // (a) word = action
        if (lower === "wheat") {
          const ok = spawnTile(w2, TILE.WHEAT, rnd, weights);
          if (ok && tileDefs[TILE.WHEAT].loreOnSpawn) pushLore(tileDefs[TILE.WHEAT].lore);
          if (ok && Math.random() < 0.25 && tileDefs[TILE.WHEAT].loreOnSpawn === 0) pushLore(randomOne([
            "Golden shoots push through damp soil.",
            "Farmers in the north whisper: the fields stir again.",
            "A faint rustle: kernels greet the wind.",
          ], Math.random));
        }

        // (b) word = chance
        if (lower === "rain") {
          w2.meta.rainMeter = clamp((w2.meta.rainMeter || 0) + 0.04 + weights.rainBias * 0.04, 0, 1);
          if (w2.meta.rainMeter > 0.7 + (weights.chaos * (Math.random() - 0.5))) {
            doRain(w2, rnd, weights);
            pushLore("Clouds gather. A soft percussion begins. Mundo drinks.");
            w2.meta.rainMeter = 0;
          }
        }
        if (lower === "sun") w2.meta.rainMeter = clamp((w2.meta.rainMeter || 0) - 0.06, 0, 1);
        if (lower === "flood") { if (Math.random() < 0.2 + weights.floodIntensity * 0.3) { doFlood(w2, rnd, weights); pushLore("Rivers swell their banks. Lowlands watch with concern."); } }

        // (c) sequences (witch circle)
        advanceSequence(lower, sequenceRef, (stage) => {
          if (stage === 1) pushLore("A hush. Something old wakes.");
          if (stage === 2) pushLore("Crows spiral. The air smells of iron.");
        }, () => { summonWitchCircle(w2, rnd); pushLore("A witch circle blossoms in the bog. Songs in a tongue you almost recall."); });

        // (live verbs)
        applyCustomVerbs(w2, lower);

        // (ownership) founding villages
        const m = /^found\s+([a-z][a-z0-9\- ]{1,20})$/i.exec(lower);
        if (m) {
          const rawName = m[1].replace(/\s+/g, ' ').trim();
          const set = petitionsRef.current.get(rawName) || new Set();
          set.add(uid || "anon");
          petitionsRef.current.set(rawName, set);
          const needed = 10;
          const have = set.size;
          pushLore(`Petitions for village '${rawName}': ${have}/${needed}`);
          if (have >= needed) {
            const placed = placeVillage(w2, rawName, rnd);
            if (placed) { pushLore(`A village is founded: ${rawName}.`); petitionsRef.current.delete(rawName); }
          }
        }

        // (d) plurality drift
        applyPlurality(w2, countsRef.current, weights, rnd);

        setWorld({ ...w2 });
      }

      // camera
      function nudge(dx, dy) {
        setView(v => ({ ...v, x: clamp(v.x + dx, 0, WORLD_W - v.w), y: clamp(v.y + dy, 0, WORLD_H - v.h) }));
      }
      function zoom(delta) {
        setView(v => {
          const z = clamp(v.zoom + delta, 0.6, 2.5);
          const scale = Math.round(START_SCALE * z);
          return { ...v, zoom: z, scale };
        });
      }

      // canvas interactions (hover → coords with bottom-left origin)
      React.useEffect(() => {
        const el = canvasRef.current; if (!el) return;
        function onMove(e) {
          const rect = el.getBoundingClientRect();
          const tx = Math.floor((e.clientX - rect.left) / view.scale);
          const ty = Math.floor((e.clientY - rect.top) / view.scale);
          const gx = clamp(view.x + tx, 0, WORLD_W - 1);
          const gy = clamp(view.y + ty, 0, WORLD_H - 1);
          const idx = gy * WORLD_W + gx;
          const name = world.villages[idx] || "";
          hoverRef.current = { x: gx, y: gy, name };
        }
        function onLeave() { hoverRef.current = { x: -1, y: -1, name: "" }; }
        el.addEventListener('mousemove', onMove);
        el.addEventListener('mouseleave', onLeave);
        return () => { el.removeEventListener('mousemove', onMove); el.removeEventListener('mouseleave', onLeave); };
      }, [view, world]);

      // tooltip label
      const [tooltip, setTooltip] = React.useState("");
      React.useEffect(() => {
        const iv = setInterval(() => {
          const h = hoverRef.current; if (!canvasRef.current) return;
          if (h.x >= 0) {
            const x1 = h.x + 1;                // X is 1-indexed
            const yBL = WORLD_H - h.y;         // bottom-left origin
            const village = h.name ? ` • Village: ${h.name}` : "";
            setTooltip(`(${x1},${yBL})${village}`);
          } else setTooltip("");
        }, 120);
        return () => clearInterval(iv);
      }, []);

      return (
        <div className="mx-auto grid max-w-7xl grid-cols-1 gap-4 px-4 py-4 md:grid-cols-3">
          {/* World column */}
          <div className="md:col-span-2">
            <div className="mb-3 flex items-center justify-between">
              <div className="text-lg font-semibold">Mundo</div>
              <div className="flex items-center gap-3 text-xs text-slate-400">
                <div>Seed: <code className="text-emerald-300">{seed.slice(0, 6)}</code></div>
                <div className="hidden sm:flex items-center gap-1">
                  <button onClick={() => zoom(-0.1)} className="rounded bg-slate-800 px-2 py-0.5">−</button>
                  <button onClick={() => zoom(+0.1)} className="rounded bg-slate-800 px-2 py-0.5">+</button>
                  <button onClick={() => nudge(-20,0)} className="rounded bg-slate-800 px-2 py-0.5">◀</button>
                  <button onClick={() => nudge(20,0)} className="rounded bg-slate-800 px-2 py-0.5">▶</button>
                  <button onClick={() => nudge(0,-20)} className="rounded bg-slate-800 px-2 py-0.5">▲</button>
                  <button onClick={() => nudge(0,20)} className="rounded bg-slate-800 px-2 py-0.5">▼</button>
                </div>
                <div className="flex items-center gap-1">
                  <span>WS:</span>
                  <input value={wsUrl} onChange={(e) => setWsUrl(e.target.value)} placeholder="wss://host" className="rounded bg-slate-900 px-2 py-0.5 text-xs ring-1 ring-slate-700 w-40" />
                </div>
              </div>
            </div>
            <div className="overflow-hidden rounded-2xl border border-slate-800 shadow-inner shadow-black/20 relative">
              <canvas ref={canvasRef} width={view.w * view.scale} height={view.h * view.scale} className="block w-full bg-slate-900" />
              {tooltip && (
                <div className="pointer-events-none absolute bottom-2 right-2 rounded bg-black/60 px-2 py-1 text-xs text-slate-200">
                  {tooltip}
                </div>
              )}
            </div>
            <Legend />
          </div>

          {/* Right column */}
          <div className="flex min-h-[560px] flex-col gap-3">
            {/* Chat */}
            <div className="rounded-2xl border border-slate-800">
              <div className="flex items-center justify-between border-b border-slate-800 p-2">
                <div className="text-lg font-semibold">Chat</div>
                <div className="text-xs text-slate-400">Try: wheat, rain, sun, flood, sand, quicksand, found Riverton</div>
              </div>
              <div className="h-72 overflow-y-auto p-3 text-sm" id="chatScroll">
                {messages.map(m => (
                  <div key={m.id} className="mb-1">
                    <span className="text-emerald-300">{m.user}</span>
                    <span className="mx-2 text-slate-500">•</span>
                    <span className="text-slate-200">{m.text}</span>
                  </div>
                ))}
                {messages.length === 0 && (<div className="text-slate-500">No messages yet. Be the first to guide Mundo.</div>)}
              </div>
              <div className="flex items-center gap-2 border-t border-slate-800 p-2">
                <input value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={(e) => { if (e.key === "Enter") handleSend(); }} placeholder="Type a word… (/admin to open Director Console)" className="flex-1 rounded-xl bg-slate-900 px-3 py-2 text-sm outline-none ring-1 ring-slate-700 placeholder:text-slate-500 focus:ring-emerald-500" />
                <button onClick={handleSend} className="rounded-xl bg-emerald-500 px-3 py-2 text-sm font-semibold text-emerald-950 hover:bg-emerald-400">Send</button>
              </div>
            </div>

            {/* Lore */}
            <div className="rounded-2xl border border-slate-800">
              <div className="flex items-center justify-between border-b border-slate-800 p-2">
                <div className="text-sm font-semibold">Lore feed</div>
                <button onClick={() => setSeed(Math.random().toString(36).slice(2))} className="text-xs text-slate-400 underline decoration-dotted underline-offset-2">reseed world</button>
              </div>
              <div className="h-56 overflow-y-auto p-3 text-sm">
                {lore.map(l => (
                  <div key={l.id} className="mb-2">
                    <div className="text-slate-300">{l.text}</div>
                    <div className="text-[10px] text-slate-500">{new Date(l.ts).toLocaleTimeString()}</div>
                  </div>
                ))}
              </div>
            </div>

            {/* Director Console + Admin Chat */}
            {showAdmin && (
              <div className="rounded-2xl border border-slate-800">
                <DirectorConsole
                  weights={weights}
                  setWeights={setWeights}
                  onReseed={() => setSeed(Math.random().toString(36).slice(2))}
                />
                <div className="border-t border-slate-800 p-2 text-sm font-semibold">Admin Chat</div>
                <div className="h-32 overflow-y-auto p-3 text-sm">
                  {adminMessages.map(m => (
                    <div key={m.id} className="mb-1"><span className="text-fuchsia-400">{m.user}</span> <span className="text-slate-500">•</span> {m.text}</div>
                  ))}
                  {adminMessages.length === 0 && <div className="text-slate-500">No admin messages yet. Use commands below.</div>}
                </div>
                <div className="flex items-center gap-2 border-t border-slate-800 p-2">
                  <input value={adminInput} onChange={(e) => setAdminInput(e.target.value)} onKeyDown={(e) => { if (e.key === "Enter") handleAdminSend(); }} placeholder="Type admin command or verb (e.g., add spawn myseed gold)…" className="flex-1 rounded-xl bg-slate-900 px-3 py-2 text-sm outline-none ring-1 ring-slate-700 placeholder:text-slate-500 focus:ring-fuchsia-400" />
                  <button onClick={handleAdminSend} className="rounded-xl bg-fuchsia-500 px-3 py-2 text-sm font-semibold text-fuchsia-950 hover:bg-fuchsia-400">Run</button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function Legend() {
      const used = [TILE.GRASS, TILE.WATER, TILE.WHEAT, TILE.SAND, TILE.TREES, TILE.GOLD, TILE.MOUNTAIN, TILE.VILLAGE, TILE.WITCH];
      return (
        <div className="mt-3 grid grid-cols-2 gap-2 text-xs text-slate-400 md:grid-cols-4">
          {used.map(id => <LegendItem key={id} color={tileDefs[id].hex} label={tileDefs[id].name} />)}
        </div>
      );
    }
    function LegendItem({ color, label }) {
      return (
        <div className="flex items-center gap-2">
          <div className="h-3 w-3 rounded" style={{ backgroundColor: color }} />
          <div>{label}</div>
        </div>
      );
    }

    function DirectorConsole({ weights, setWeights, onReseed }) {
      return (
        <div className="rounded-2xl border border-slate-800">
          <div className="border-b border-slate-800 p-2 text-sm font-semibold flex items-center justify-between">
            <span>Director Console</span>
            <button onClick={onReseed} className="text-xs rounded bg-slate-800 px-2 py-1">Reseed</button>
          </div>
          <div className="space-y-3 p-3 text-sm">
            <Slider label="Rain bias" min={-1} max={1} step={0.01} value={weights.rainBias} onChange={(v) => setWeights((w) => ({ ...w, rainBias: v }))} />
            <Slider label="Flood intensity" min={0} max={1} step={0.01} value={weights.floodIntensity} onChange={(v) => setWeights((w) => ({ ...w, floodIntensity: v }))} />
            <Slider label="Spawn boost" min={-1} max={1} step={0.01} value={weights.spawnBoost} onChange={(v) => setWeights((w) => ({ ...w, spawnBoost: v }))} />
            <Slider label="Chaos" min={0} max={1} step={0.01} value={weights.chaos} onChange={(v) => setWeights((w) => ({ ...w, chaos: v }))} />
            <Slider label="Quicksand sensitivity" min={0.1} max={0.8} step={0.01} value={weights.quicksandSensitivity} onChange={(v) => setWeights((w) => ({ ...w, quicksandSensitivity: v }))} />
          </div>
        </div>
      );
    }
    function Slider({ label, value, onChange, min = 0, max = 1, step = 0.01 }) {
      return (
        <div>
          <div className="mb-1 flex items-center justify-between">
            <div>{label}</div>
            <div className="tabular-nums text-slate-300">{value.toFixed(2)}</div>
          </div>
          <input type="range" min={min} max={max} step={step} value={value} onChange={(e) => onChange(parseFloat(e.target.value))} className="w-full accent-emerald-400" />
        </div>
      );
    }

    /********************
     * World generation *
     ********************/
    function makeInitialWorld(rnd) {
      const grid = new Uint8Array(WORLD_W * WORLD_H);
      const height = new Float32Array(WORLD_W * WORLD_H);
      const moisture = new Float32Array(WORLD_W * WORLD_H);
      const idx = (x, y) => y * WORLD_W + x;

      function blobs(kind, count, steps, spread) {
        for (let b = 0; b < count; b++) {
          let x = (rnd() * WORLD_W) | 0, y = (rnd() * WORLD_H) | 0;
          for (let s = 0; s < steps; s++) {
            const r = (rnd() * spread) | 0;
            for (let i = 0; i < r; i++) {
              const xx = clamp(x + ((rnd() < 0.5 ? -1 : 1) * (rnd() * 2) | 0), 0, WORLD_W - 1);
              const yy = clamp(y + ((rnd() < 0.5 ? -1 : 1) * (rnd() * 2) | 0), 0, WORLD_H - 1);
              grid[idx(xx, yy)] = kind;
            }
            x = clamp(x + (rnd() < 0.5 ? -1 : 1), 0, WORLD_W - 1);
            y = clamp(y + (rnd() < 0.5 ? -1 : 1), 0, WORLD_H - 1);
          }
        }
      }

      // base
      grid.fill(TILE.GRASS);
      // water systems
      blobs(TILE.WATER, 25, 900, 18);
      // dry belts
      blobs(TILE.SAND, 18, 700, 14);
      // mountains (terrain)
      blobs(TILE.MOUNTAIN, 30, 1200, 20);
      // tree belts
      blobs(TILE.TREES, 40, 600, 16);

      // height & moisture pass
      for (let y = 0; y < WORLD_H; y++) {
        for (let x = 0; x < WORLD_W; x++) {
          const id = idx(x, y);
          const t = grid[id];
          let h = 0.5 + (Math.random() - 0.5) * 0.1;
          if (t === TILE.MOUNTAIN) h += 0.25;
          if (t === TILE.WATER) h -= 0.2;
          let m = 0.4 + (Math.random() - 0.5) * 0.1 + (t === TILE.WATER ? 0.35 : 0);
          if (t === TILE.SAND) m -= 0.15;
          if (t === TILE.MOUNTAIN) m -= 0.05;
          height[id] = clamp(h, 0, 1);
          moisture[id] = clamp(m, 0, 1);
        }
      }

      // rare gold veins in/near mountains
      let goldPlaced = 0;
      for (let tries = 0; tries < 50000 && goldPlaced < 800; tries++) {
        const x = (Math.random()*WORLD_W)|0, y = (Math.random()*WORLD_H)|0; const i = idx(x,y);
        if (grid[i] === TILE.MOUNTAIN && Math.random() < 0.02) { grid[i] = TILE.GOLD; goldPlaced++; }
      }

      return {
        grid, height, moisture,
        meta: { rainMeter: 0, memory: [] },
        villages: {}, // index -> name
      };
    }

    function worldCount(world, kind) {
      const { grid } = world; let n = 0;
      for (let i = 0; i < grid.length; i++) if (grid[i] === kind) n++;
      return n;
    }

    /****************
     * Tick/FX      *
     ****************/
    function neighbors(x, y) {
      const out = [];
      for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const xx = x + dx, yy = y + dy;
        if (xx >= 0 && yy >= 0 && xx < WORLD_W && yy < WORLD_H) out.push({ x: xx, y: yy });
      }
      return out;
    }

    function tickWorldSampled(world, rnd, weights) {
      const { grid, moisture } = world;
      const N = grid.length;
      for (let k = 0; k < SIM_SAMPLE_PER_TICK; k++) {
        const i = (Math.random() * N) | 0;
        const t = grid[i];

        // moisture drift
        if (t === TILE.WATER) moisture[i] = clamp(moisture[i] + 0.0008, 0, 1);
        else moisture[i] = clamp(moisture[i] - 0.0004, 0, 1);

        // wheat slow growth/wither
        if (t === TILE.WHEAT) {
          if (moisture[i] < 0.22 && Math.random() < 0.0008) grid[i] = TILE.GRASS;
          if (moisture[i] > 0.7 && Math.random() < 0.001) spreadWheatAtIndex(world, i, rnd, weights);
        }

        // slow desertification
        if (t === TILE.GRASS && moisture[i] < 0.15 && Math.random() < 0.0005) grid[i] = TILE.SAND;
      }
      return world;
    }

    function spawnTile(world, kind, rnd, weights) {
      const { grid, moisture } = world; const N = grid.length;
      for (let tries = 0; tries < 200; tries++) {
        const i = (Math.random() * N) | 0;
        if (grid[i] === TILE.GRASS && moisture[i] > 0.28 && Math.random() < 0.55 + (weights.spawnBoost * 0.25)) {
          grid[i] = kind;
          return true;
        }
      }
      return false;
    }

    function spreadWheatAtIndex(world, i, rnd, weights) {
      const { grid } = world; const x = i % WORLD_W, y = (i / WORLD_W) | 0; const nbs = neighbors(x, y);
      const nb = nbs[(Math.random() * nbs.length) | 0]; const j = nb.y * WORLD_W + nb.x;
      if (grid[j] === TILE.GRASS && Math.random() < 0.5 + weights.spawnBoost * 0.2) grid[j] = TILE.WHEAT;
    }

    function doRain(world, rnd, weights) {
      const { moisture, grid } = world;
      for (let k = 0; k < SIM_SAMPLE_PER_TICK * 5; k++) {
        const i = (Math.random()*grid.length)|0;
        moisture[i] = clamp(moisture[i] + 0.12 + weights.chaos * (Math.random() - 0.5) * 0.05, 0, 1);
        if (grid[i] === TILE.GRASS && moisture[i] > 0.75 && Math.random() < 0.003) grid[i] = TILE.WHEAT;
      }
    }

    function doFlood(world, rnd, weights) {
      const { grid, moisture } = world;
      const floodChance = 0.006 + weights.floodIntensity * 0.02;
      for (let k = 0; k < SIM_SAMPLE_PER_TICK * 4; k++) {
        const i = (Math.random()*grid.length)|0;
        if (grid[i] === TILE.WATER) {
          const x = i % WORLD_W, y = (i / WORLD_W) | 0; const nbs = neighbors(x, y);
          const nb = nbs[(Math.random()*nbs.length)|0]; const j = nb.y * WORLD_W + nb.x;
          if (grid[j] !== TILE.WATER && Math.random() < floodChance) grid[j] = TILE.WATER;
        }
        if (grid[i] !== TILE.WATER) moisture[i] = clamp(moisture[i] + 0.03, 0, 1);
      }
    }

    function summonWitchCircle(world, rnd) {
      const { grid, moisture } = world; let cx = 0, cy = 0; let best = -1;
      for (let tries = 0; tries < 2000; tries++) {
        const x = (Math.random() * WORLD_W) | 0, y = (Math.random() * WORLD_H) | 0; const m = moisture[y * WORLD_W + x];
        if (m > best) { best = m; cx = x; cy = y; }
      }
      const radius = 8 + ((Math.random() * 8) | 0);
      for (let y = Math.max(0, cy - radius - 1); y < Math.min(WORLD_H, cy + radius + 1); y++) {
        for (let x = Math.max(0, cx - radius - 1); x < Math.min(WORLD_W, cx + radius + 1); x++) {
          const dx = x - cx, dy = y - cy; const d = Math.sqrt(dx * dx + dy * dy);
          if (Math.abs(d - radius) < 1.2) grid[y * WORLD_W + x] = TILE.WITCH;
        }
      }
    }

    function advanceSequence(word, sequenceRef, onStage, onComplete) {
      const seq = ["eye-of-newt", "toe-of-frog", "wing-of-bat"];
      const now = Date.now(); const timeout = 45000;
      const st = sequenceRef.current;
      if (now - st.lastTs > timeout) st.stage = 0;
      if (word === seq[st.stage]) { st.stage += 1; st.lastTs = now; onStage(st.stage); if (st.stage >= seq.length) { onComplete(); st.stage = 0; } }
    }

    function applyPlurality(world, counts, weights, rnd) {
      let total = 0; let maxWord = ""; let maxCount = 0;
      for (const [w, arr] of counts.entries()) { total += arr.length; if (arr.length > maxCount) { maxCount = arr.length; maxWord = w; } }
      if (total === 0) return;
      const share = maxCount / total;
      if ((maxWord === "sand" || maxWord === "quicksand") && share > weights.quicksandSensitivity) sandify(world);
    }

    function sandify(world) {
      const { grid, moisture } = world; const N = grid.length;
      for (let k = 0; k < SIM_SAMPLE_PER_TICK * 2; k++) {
        const i = (Math.random()*N)|0;
        if (grid[i] === TILE.GRASS && moisture[i] < 0.5 && Math.random() < 0.006) grid[i] = TILE.SAND;
        if (grid[i] === TILE.WHEAT && Math.random() < 0.004) grid[i] = TILE.SAND;
      }
    }

    function placeVillage(world, name, rnd) {
      const { grid } = world; const N = grid.length;
      for (let tries = 0; tries < 2000; tries++) {
        const i = (Math.random()*N)|0; if (grid[i] !== TILE.GRASS) continue;
        if (Math.random() < 0.7) { grid[i] = TILE.VILLAGE; world.villages[i] = name; return true; }
      }
      return false;
    }

    // drawing
    function draw(canvas, world, view, palette) {
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startX = view.x, startY = view.y;
      const endX = Math.min(startX + view.w, WORLD_W);
      const endY = Math.min(startY + view.h, WORLD_H);

      const { grid } = world; const scale = view.scale;
      for (let y = startY, sy = 0; y < endY; y++, sy++) {
        const rowOff = y * WORLD_W;
        for (let x = startX, sx = 0; x < endX; x++, sx++) {
          const t = grid[rowOff + x];
          const [r,g,b] = palette[t] || [0,0,0];
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(sx * scale, sy * scale, scale, scale);
        }
      }

      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      for (let x = 0; x <= view.w; x++) { ctx.beginPath(); ctx.moveTo(x * scale + 0.5, 0); ctx.lineTo(x * scale + 0.5, view.h * scale); ctx.stroke(); }
      for (let y = 0; y <= view.h; y++) { ctx.beginPath(); ctx.moveTo(0, y * scale + 0.5); ctx.lineTo(view.w * scale, y * scale + 0.5); ctx.stroke(); }
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
